(function (w) {
  'use strict';

  // ===== Core =====
  const Core = {};
  Core.qs  = (s, r = document) => r.querySelector(s);
  Core.qsa = (s, r = document) => Array.from(r.querySelectorAll(s));

  Core.ready = (fn) => {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', fn, { once: true });
    } else fn();
  };

  Core.throttle = (fn, wait = 80) => {
    let last = 0, t = null;
    return (...args) => {
      const now = Date.now();
      const rem = wait - (now - last);
      if (rem <= 0) { last = now; fn(...args); }
      else if (!t) {
        t = setTimeout(() => { t = null; last = Date.now(); fn(...args); }, rem);
      }
    };
  };

  Core.lockScroll = () => {
    const html = document.documentElement;
    if (html.classList.contains('mod-scroll-locked')) return;
    const sbw = w.innerWidth - html.clientWidth;
    html.style.setProperty('--mod-scrollbar-w', sbw + 'px');
    html.classList.add('mod-scroll-locked');
  };

  Core.unlockScroll = () => {
    const html = document.documentElement;
    html.classList.remove('mod-scroll-locked');
    html.style.removeProperty('--mod-scrollbar-w');
  };

  Core.observe = (cb, root = document.body) => {
    const mo = new MutationObserver((m) => {
      if (m.some(x => x.addedNodes && x.addedNodes.length)) cb(m);
    });
    mo.observe(root, { childList: true, subtree: true });
    return () => mo.disconnect();
  };

  Core.whenBothExist = (fromSel, toSel, cb, { timeout = 12000, poll = 120 } = {}) => {
    const start = Date.now();
    (function tick() {
      const a = Core.qs(fromSel), b = Core.qs(toSel);
      if (a && b) return cb(a, b);
      if (Date.now() - start > timeout) return;
      setTimeout(tick, poll);
    })();
  };

  Core.isDesktop = (bp = 980) => w.innerWidth >= bp;

  Core.normPath = (url) => {
    try {
      const u = new URL(url, location.origin);
      let p = u.pathname.replace(/\/$/, '');
      if (p === '') p = '/';
      return p;
    } catch {
      return null;
    }
  };

  // ===== Tilda hooks =====
  const Tilda = {};
  Tilda.mount = (fn, { observe = true } = {}) => {
    Core.ready(fn);
    w.addEventListener('load', fn);
    const off = observe ? Core.observe(() => fn()) : () => {};
    return () => off();
  };

  // ===== stickyHeader =====
  const stickyMap = new WeakMap();
  const stickyHeader = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({
        headerSel: '.uc-header',
        scrolledClass: 'is-scrolled',
        threshold: 10,
        setHeaderHeightVar: true,         // <-- выставлять --mods-header-h
        headerHeightVarName: '--mods-header-h'
      }, p);

      Core.qsa(rootSel || 'body').forEach(root => {
        if (stickyMap.has(root)) return;
        const header = root.matches(cfg.headerSel) ? root : Core.qs(cfg.headerSel, root) || Core.qs(cfg.headerSel);
        if (!header) return;

        const updateHeaderVar = () => {
          if (!cfg.setHeaderHeightVar) return;
          const h = Math.round(header.getBoundingClientRect().height);
          if (h > 0) document.documentElement.style.setProperty(cfg.headerHeightVarName, h + 'px');
        };

        const onScroll = Core.throttle(() => {
          const y = w.scrollY || document.documentElement.scrollTop || 0;
          header.classList.toggle(cfg.scrolledClass, y > cfg.threshold);
        }, 80);

        const onResize = Core.throttle(() => updateHeaderVar(), 120);

        w.addEventListener('scroll', onScroll, { passive: true });
        w.addEventListener('resize', onResize);

        onScroll();
        updateHeaderVar();

        stickyMap.set(root, { onScroll, onResize, header, cfg });
      });
    },
    destroy(rootSel) {
      Core.qsa(rootSel || 'body').forEach(root => {
        const s = stickyMap.get(root);
        if (!s) return;
        w.removeEventListener('scroll', s.onScroll);
        w.removeEventListener('resize', s.onResize);
        s.header.classList.remove(s.cfg.scrolledClass);
        stickyMap.delete(root);
      });
    }
  };

  // ===== burgerMenu =====
  const burgerMap = new WeakMap();
  const burgerMenu = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({
        menuSel: '.uc-menu',
        backdropSel: '.menu-backdrop',
        panelSel: '.menu-panel',
        openBtnSel: '#menu',
        closeBtnSel: '#menu-close',
        openClassMenu: 'is-open',
        openClassHtml: 'is-menu-open',
        closeOnEsc: true,
        closeOnBackdropClick: true,
        closeOnLinkClick: true,
        linkSel: 'a[href]'
      }, p);

      Core.qsa(rootSel || 'body').forEach(root => {
        if (burgerMap.has(root)) return;

        const menu = Core.qs(cfg.menuSel) || Core.qs(cfg.menuSel, root);
        const openBtn = Core.qs(cfg.openBtnSel);
        const closeBtn = Core.qs(cfg.closeBtnSel);
        if (!menu || !openBtn) return;

        const backdrop = Core.qs(cfg.backdropSel, menu);
        const panel = Core.qs(cfg.panelSel, menu);

        let isOpen = false;

        const open = (e) => {
          if (e) e.preventDefault();
          if (isOpen) return;
          isOpen = true;

          menu.classList.add(cfg.openClassMenu);
          document.documentElement.classList.add(cfg.openClassHtml);
          Core.lockScroll();

          openBtn.setAttribute('aria-expanded', 'true');
          menu.setAttribute('aria-hidden', 'false');
          menu.setAttribute('role', 'dialog');
          menu.setAttribute('aria-modal', 'true');
        };

        const close = (e) => {
          if (e && e.preventDefault) e.preventDefault();
          if (!isOpen) return;
          isOpen = false;

          menu.classList.remove(cfg.openClassMenu);
          document.documentElement.classList.remove(cfg.openClassHtml);
          Core.unlockScroll();

          openBtn.setAttribute('aria-expanded', 'false');
          menu.setAttribute('aria-hidden', 'true');
          menu.removeAttribute('role');
          menu.removeAttribute('aria-modal');
        };

        const onBackdrop = (e) => {
          if (!cfg.closeOnBackdropClick || !isOpen) return;
          if (backdrop && e.target === backdrop) close();
        };

        const onKey = (e) => {
          if (!cfg.closeOnEsc) return;
          if (e.key === 'Escape') close();
        };

        const onLink = (e) => {
          if (!cfg.closeOnLinkClick || !isOpen) return;
          const a = e.target.closest(cfg.linkSel);
          if (!a) return;
          // навигацию не блокируем
          close();
        };

        openBtn.addEventListener('click', open);
        if (closeBtn) closeBtn.addEventListener('click', close);
        if (backdrop) backdrop.addEventListener('click', onBackdrop);
        (panel || menu).addEventListener('click', onLink);
        document.addEventListener('keydown', onKey);

        burgerMap.set(root, { cfg, open, close, onBackdrop, onLink, onKey, menu, openBtn, closeBtn, backdrop, panel });
      });
    },
    destroy(rootSel) {
      Core.qsa(rootSel || 'body').forEach(root => {
        const s = burgerMap.get(root);
        if (!s) return;
        s.openBtn.removeEventListener('click', s.open);
        if (s.closeBtn) s.closeBtn.removeEventListener('click', s.close);
        if (s.backdrop) s.backdrop.removeEventListener('click', s.onBackdrop);
        (s.panel || s.menu).removeEventListener('click', s.onLink);
        document.removeEventListener('keydown', s.onKey);
        s.menu.classList.remove(s.cfg.openClassMenu);
        document.documentElement.classList.remove(s.cfg.openClassHtml);
        Core.unlockScroll();
        burgerMap.delete(root);
      });
    }
  };

  // ===== submenu =====
  const submenuMap = new WeakMap();
  const submenu = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({
        headerSel: '.uc-header',
        triggerSel: '.submenu',   // обычно <a>
        panelSel: '.uc-submenu',

        openClass: 'is-open',
        activeClass: 'is-active',

        mode: 'mixed',            // hover|click|mixed
        desktopBp: 980,

        mixedClickThrough: true,  // десктоп: клик НЕ перехватываем
        closeDelay: 180,
        closeOnOutside: true,
        closeOnEsc: true,

        doubleTapWindow: 900,
        overlay: true             // <-- добавит html.mod-submenu-overlay
      }, p);

      Core.qsa(rootSel || 'body').forEach(root => {
        if (submenuMap.has(root)) return;

        const header = Core.qs(cfg.headerSel, root) || Core.qs(cfg.headerSel);
        if (!header) return;

        const triggers = Core.qsa(cfg.triggerSel, header);
        const panels = Core.qsa(cfg.panelSel, document);
        const n = Math.min(triggers.length, panels.length);
        if (!n) return;

        if (cfg.overlay) document.documentElement.classList.add('mod-submenu-overlay');

        const pairs = [];
        for (let i = 0; i < n; i++) pairs.push({ t: triggers[i], p: panels[i], i });

        let closeTimer = null;
        let lastTapIdx = -1;
        let lastTapAt = 0;

        const isDesktop = () => Core.isDesktop(cfg.desktopBp);
        const shouldHover = () => cfg.mode === 'hover' || (cfg.mode === 'mixed' && isDesktop());

        const closeAll = () => {
          lastTapIdx = -1;
          lastTapAt = 0;
          pairs.forEach(({ t, p }) => {
            t.classList.remove(cfg.activeClass);
            p.classList.remove(cfg.openClass);
            t.setAttribute('aria-expanded', 'false');
          });
        };

        const openOnly = (idx) => {
          pairs.forEach(({ t, p, i }) => {
            const on = i === idx;
            t.classList.toggle(cfg.activeClass, on);
            p.classList.toggle(cfg.openClass, on);
            t.setAttribute('aria-expanded', on ? 'true' : 'false');
          });
        };

        const scheduleClose = () => {
          clearTimeout(closeTimer);
          closeTimer = setTimeout(closeAll, cfg.closeDelay);
        };
        const cancelClose = () => {
          clearTimeout(closeTimer);
          closeTimer = null;
        };

        const handlers = [];

        pairs.forEach(({ t, p, i }) => {
          t.setAttribute('aria-haspopup', 'true');
          t.setAttribute('aria-expanded', 'false');

          const onEnter = () => { if (shouldHover()) { cancelClose(); openOnly(i); } };
          const onLeave = () => { if (shouldHover()) scheduleClose(); };

          t.addEventListener('mouseenter', onEnter);
          t.addEventListener('mouseleave', onLeave);
          p.addEventListener('mouseenter', cancelClose);
          p.addEventListener('mouseleave', () => { if (shouldHover()) scheduleClose(); });

          handlers.push([t,'mouseenter',onEnter],[t,'mouseleave',onLeave],[p,'mouseenter',cancelClose]);

          const onClick = (e) => {
            // десктоп: пусть кликается и переходит
            if (cfg.mode === 'mixed' && isDesktop() && cfg.mixedClickThrough) return;

            // мобилка: 1-й тап открыть, 2-й тап (в окне) перейти
            const now = Date.now();
            const isOpen = p.classList.contains(cfg.openClass);

            if (isOpen && lastTapIdx === i && (now - lastTapAt) <= cfg.doubleTapWindow) {
              lastTapIdx = -1;
              lastTapAt = 0;
              return; // НЕ preventDefault => переход по href
            }

            e.preventDefault();
            openOnly(i);
            lastTapIdx = i;
            lastTapAt = now;
          };

          t.addEventListener('click', onClick);
          handlers.push([t,'click',onClick]);
        });

        const onDocClick = (e) => {
          if (!cfg.closeOnOutside) return;
          const inside = pairs.some(({ t, p }) => t.contains(e.target) || p.contains(e.target));
          if (!inside) closeAll();
        };

        const onKey = (e) => {
          if (!cfg.closeOnEsc) return;
          if (e.key === 'Escape') closeAll();
        };

        document.addEventListener('click', onDocClick);
        document.addEventListener('keydown', onKey);
        handlers.push([document,'click',onDocClick],[document,'keydown',onKey]);

        submenuMap.set(root, { handlers });
      });
    },
    destroy(rootSel) {
      Core.qsa(rootSel || 'body').forEach(root => {
        const s = submenuMap.get(root);
        if (!s) return;
        s.handlers.forEach(([el, type, fn]) => el.removeEventListener(type, fn));
        submenuMap.delete(root);
      });
    }
  };

  // ===== widgetMove =====
  const widgetMap = new WeakMap();
  const widgetMove = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({
        items: [],
        mode: 'append',
        observe: true
      }, p);

      Core.qsa(rootSel || 'body').forEach(root => {
        if (widgetMap.has(root)) return;

        const apply = () => {
          (cfg.items || []).forEach(item => {
            const fromSel = item.from, toSel = item.to;
            const mode = item.mode || cfg.mode;
            if (!fromSel || !toSel) return;

            Core.whenBothExist(fromSel, toSel, (fromEl, toEl) => {
              if (toEl.contains(fromEl)) return;

              if (mode === 'replace') { toEl.innerHTML = ''; toEl.appendChild(fromEl); }
              else if (mode === 'prepend') { toEl.insertBefore(fromEl, toEl.firstChild); }
              else { toEl.appendChild(fromEl); }
            });
          });
        };

        apply();
        const off = cfg.observe ? Core.observe(apply) : () => {};
        widgetMap.set(root, { off });
      });
    },
    destroy(rootSel) {
      Core.qsa(rootSel || 'body').forEach(root => {
        const s = widgetMap.get(root);
        if (!s) return;
        s.off();
        widgetMap.delete(root);
      });
    }
  };

  // ===== activePage =====
  const activeMap = new WeakMap();
  const activePage = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({
        containers: ['.uc-header', '.uc-menu'],
        pageSel: '.page',
        pageElemSel: '.page-elem',
        activeClass: 'is-active',
        linkActiveClass: 'is-active'
      }, p);

      Core.qsa(rootSel || 'body').forEach(root => {
        if (activeMap.has(root)) return;

        const run = () => {
          const cur = (location.pathname || '/').replace(/\/$/, '') || '/';

          cfg.containers.forEach(sel => {
            const box = Core.qs(sel, root) || Core.qs(sel);
            if (!box) return;

            // 1) Если есть .page — работаем через него
            const pages = Core.qsa(cfg.pageSel, box);
            if (pages.length) {
              pages.forEach(page => {
                const link = page.matches('a[href]') ? page : Core.qs('a[href]', page);
                const href = link ? link.getAttribute('href') : null;
                const norm = href ? Core.normPath(href) : null;

                const isActive = norm && norm === cur;

                page.classList.toggle(cfg.activeClass, !!isActive);
                if (link) link.classList.toggle(cfg.linkActiveClass, !!isActive);

                const deco = Core.qs(cfg.pageElemSel, page);
                if (deco) deco.classList.toggle(cfg.activeClass, !!isActive);
              });
              return;
            }

            // 2) Если .page нет — хотя бы подсветим ссылки
            Core.qsa('a[href]', box).forEach(a => {
              const href = a.getAttribute('href');
              const norm = href ? Core.normPath(href) : null;
              a.classList.toggle(cfg.linkActiveClass, !!(norm && norm === cur));
            });
          });
        };

        run();
        w.addEventListener('popstate', run);
        activeMap.set(root, { run });
      });
    },
    destroy(rootSel) {
      Core.qsa(rootSel || 'body').forEach(root => {
        const s = activeMap.get(root);
        if (!s) return;
        w.removeEventListener('popstate', s.run);
        activeMap.delete(root);
      });
    }
  };

  // ===== Public API =====
  const MyMods = w.MyMods || {};
  MyMods.version = '0.3.0';

  MyMods.Core = Core;
  MyMods.Tilda = Tilda;

  MyMods.stickyHeader = stickyHeader;
  MyMods.burgerMenu = burgerMenu;
  MyMods.submenu = submenu;
  MyMods.widgetMove = widgetMove;
  MyMods.activePage = activePage;

  MyMods.init = (rootSel, config = {}) => {
    if (config.stickyHeader) MyMods.stickyHeader.init(rootSel, config.stickyHeader);
    if (config.burgerMenu)   MyMods.burgerMenu.init(rootSel, config.burgerMenu);
    if (config.submenu)      MyMods.submenu.init(rootSel, config.submenu);
    if (config.widgetMove)   MyMods.widgetMove.init(rootSel, config.widgetMove);
    if (config.activePage)   MyMods.activePage.init(rootSel, config.activePage);
    console.log('[MyMods] init ok, version', MyMods.version);
  };

  MyMods.destroy = (rootSel) => {
    MyMods.stickyHeader.destroy(rootSel);
    MyMods.burgerMenu.destroy(rootSel);
    MyMods.submenu.destroy(rootSel);
    MyMods.widgetMove.destroy(rootSel);
    MyMods.activePage.destroy(rootSel);
    console.log('[MyMods] destroy ok, version', MyMods.version);
  };

  w.MyMods = MyMods;
  console.log('[MyMods] library loaded, version', MyMods.version);

})(window);
