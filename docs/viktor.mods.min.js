(function (w) {
  'use strict';

  const Core = {};
  Core.qs  = (s, r = document) => r.querySelector(s);
  Core.qsa = (s, r = document) => Array.from(r.querySelectorAll(s));

  Core.ready = (fn) => {
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn, { once: true });
    else fn();
  };

  Core.throttle = (fn, wait = 80) => {
    let last = 0, t = null;
    return (...args) => {
      const now = Date.now();
      const rem = wait - (now - last);
      if (rem <= 0) { last = now; fn(...args); }
      else if (!t) t = setTimeout(() => { t = null; last = Date.now(); fn(...args); }, rem);
    };
  };

  Core.lockScroll = () => {
    const html = document.documentElement;
    if (html.classList.contains('mod-scroll-locked')) return;
    const sbw = w.innerWidth - html.clientWidth;
    html.style.setProperty('--mod-scrollbar-w', sbw + 'px');
    html.classList.add('mod-scroll-locked');
  };

  Core.unlockScroll = () => {
    const html = document.documentElement;
    html.classList.remove('mod-scroll-locked');
    html.style.removeProperty('--mod-scrollbar-w');
  };

  Core.observe = (cb, root = document.body) => {
    const mo = new MutationObserver((m) => {
      if (m.some(x => x.addedNodes && x.addedNodes.length)) cb(m);
    });
    mo.observe(root, { childList: true, subtree: true });
    return () => mo.disconnect();
  };

  Core.whenBothExist = (fromSel, toSel, cb, { timeout = 12000, poll = 120 } = {}) => {
    const start = Date.now();
    (function tick() {
      const a = Core.qs(fromSel), b = Core.qs(toSel);
      if (a && b) return cb(a, b);
      if (Date.now() - start > timeout) return;
      setTimeout(tick, poll);
    })();
  };

  Core.isDesktop = (bp = 980) => w.innerWidth >= bp;

  Core.normPath = (url) => {
    try {
      const u = new URL(url, location.origin);
      let p = u.pathname.replace(/\/$/, '');
      if (p === '') p = '/';
      return p;
    } catch { return null; }
  };

  // Tilda: prefer working with t-rec
  Core.asRec = (el) => {
    if (!el) return null;
    if (el.classList && el.classList.contains('t-rec')) return el;
    return el.closest ? (el.closest('.t-rec') || el) : el;
  };

  const Tilda = {};
  Tilda.mount = (fn, { observe = true, throttle = 120 } = {}) => {
    const run = Core.throttle(fn, throttle);
    Core.ready(run);
    w.addEventListener('load', run);
    const off = observe ? Core.observe(() => run()) : () => {};
    return () => off();
  };

  // ===== Global hard reset =====
  const resetUIState = () => {
    const html = document.documentElement;
    html.classList.remove('is-menu-open');
    Core.unlockScroll();

    Core.qsa('.t-rec.uc-menu.is-open, .uc-menu.is-open').forEach(m => m.classList.remove('is-open'));
    Core.qsa('.t-rec.uc-submenu.is-open, .uc-submenu.is-open').forEach(s => s.classList.remove('is-open'));
    Core.qsa('.uc-header .submenu.is-active').forEach(t => {
      t.classList.remove('is-active');
      t.setAttribute('aria-expanded', 'false');
    });
  };

  // ===== stickyHeader (+ hide on scroll) =====
  const stickyMap = new WeakMap();
  const stickyHeader = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({
        headerSel: '.uc-header',
        scrolledClass: 'is-scrolled',
        threshold: 10,
        setHeaderHeightVar: true,
        headerHeightVarName: '--mods-header-h',

        hideOnScroll: false,
        hideTargetSel: '.header-shell',
        hideClass: 'is-hidden',
        hideMinY: 120,
        hideDelta: 10
      }, p);

      const headerRaw = Core.qs(cfg.headerSel);
      const header = Core.asRec(headerRaw) || headerRaw;
      if (!header) return;
      if (stickyMap.has(header)) return;

      const hideTarget =
        Core.qs(cfg.hideTargetSel, header) ||
        Core.qs(cfg.hideTargetSel) ||
        header;

      const updateHeaderVar = () => {
        if (!cfg.setHeaderHeightVar) return;
        const h = Math.round(header.getBoundingClientRect().height);
        if (h > 0) document.documentElement.style.setProperty(cfg.headerHeightVarName, h + 'px');
      };

      let lastY = w.scrollY || 0;

      const onScroll = Core.throttle(() => {
        const y = w.scrollY || document.documentElement.scrollTop || 0;

        header.classList.toggle(cfg.scrolledClass, y > cfg.threshold);

        if (cfg.hideOnScroll) {
          const html = document.documentElement;
          const menuOpen = html.classList.contains('is-menu-open');
          const submenuOpen = !!document.querySelector('.t-rec.uc-submenu.is-open, .uc-submenu.is-open');

          if (menuOpen || submenuOpen || y < cfg.hideMinY) {
            hideTarget.classList.remove(cfg.hideClass);
            lastY = y;
            return;
          }

          const diff = y - lastY;
          if (Math.abs(diff) < cfg.hideDelta) return;

          if (diff > 0) hideTarget.classList.add(cfg.hideClass);
          else hideTarget.classList.remove(cfg.hideClass);

          lastY = y;
        }
      }, 60);

      const onResize = Core.throttle(() => updateHeaderVar(), 120);

      w.addEventListener('scroll', onScroll, { passive: true });
      w.addEventListener('resize', onResize);

      onScroll();
      updateHeaderVar();

      stickyMap.set(header, { onScroll, onResize });
    }
  };

  // ===== burgerMenu =====
  const burgerMap = new WeakMap();
  const burgerMenu = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({
        menuSel: '.uc-menu',
        panelSel: '.menu-panel',
        openBtnSel: '.js-menu-open',
        closeBtnSel: '.js-menu-close',
        openClassMenu: 'is-open',
        openClassHtml: 'is-menu-open',
        closeOnEsc: true,
        closeOnBackdropClick: true,
        closeOnLinkClick: true,
        linkSel: 'a[href]',
        // анти-автозакрытие: сколько мс игнорим клики сразу после open()
        justOpenedIgnoreMs: 250,

        // ✅ ВЫКЛЮЧЕНО: скролл НЕ блокируем
        lockScroll: false
      }, p);

      const menuRaw = Core.qs(cfg.menuSel);
      if (!menuRaw) return;

      const menu = Core.asRec(menuRaw);
      if (!menu.classList.contains('uc-menu')) menu.classList.add('uc-menu');

      const openBtns = Core.qsa(cfg.openBtnSel);
      if (!openBtns.length) return;

      if (burgerMap.has(menu)) return;

      const panel = Core.qs(cfg.panelSel, menu);

      let isOpen = false;
      let openedAt = 0;

      // стартовое состояние
      menu.classList.remove(cfg.openClassMenu);
      document.documentElement.classList.remove(cfg.openClassHtml);
      // Core.unlockScroll(); // оставляю как было по эффекту (не мешает), но меню скролл не лочит

      const killEvent = (e) => {
        if (!e) return;
        if (e.preventDefault) e.preventDefault();
        if (e.stopPropagation) e.stopPropagation();
        if (e.stopImmediatePropagation) e.stopImmediatePropagation();
      };

      const open = (e) => {
        killEvent(e);
        if (isOpen) return;

        isOpen = true;
        openedAt = Date.now();

        // закрываем сабменю, если было открыто
        Core.qsa('.t-rec.uc-submenu.is-open, .uc-submenu.is-open').forEach(s => s.classList.remove('is-open'));
        Core.qsa('.uc-header .submenu.is-active').forEach(t => {
          t.classList.remove('is-active');
          t.setAttribute('aria-expanded', 'false');
        });

        menu.classList.add(cfg.openClassMenu);
        document.documentElement.classList.add(cfg.openClassHtml);

        // ✅ НЕТ lockScroll
        if (cfg.lockScroll) Core.lockScroll();
      };

      const close = (e) => {
        killEvent(e);
        if (!isOpen) return;

        isOpen = false;
        menu.classList.remove(cfg.openClassMenu);
        document.documentElement.classList.remove(cfg.openClassHtml);

        // ✅ НЕТ unlockScroll
        if (cfg.lockScroll) Core.unlockScroll();
      };

      const tooSoonAfterOpen = () => (Date.now() - openedAt) < cfg.justOpenedIgnoreMs;

      const onMenuClick = (e) => {
        if (!cfg.closeOnBackdropClick || !isOpen) return;

        // 1) игнорим клик-открытие (мобилки)
        if (tooSoonAfterOpen()) return;

        // 2) если тап по кнопкам открытия/закрытия — не считать это кликом по “бекдропу”
        if (e.target.closest(cfg.openBtnSel) || e.target.closest(cfg.closeBtnSel)) return;

        // 3) если клик внутри панели — не закрываем
        if (panel && panel.contains(e.target)) return;

        close(e);
      };

      const onKey = (e) => {
        if (!cfg.closeOnEsc) return;
        if (e.key === 'Escape') close(e);
      };

      const onLink = (e) => {
        if (!cfg.closeOnLinkClick || !isOpen) return;

        // игнорим “клик-открытие”
        if (tooSoonAfterOpen()) return;

        // не реагируем на клики по кнопкам
        if (e.target.closest(cfg.openBtnSel) || e.target.closest(cfg.closeBtnSel)) return;

        const a = e.target.closest(cfg.linkSel);
        if (!a) return;

        close(e);
      };

      // ВАЖНО: capture=true чтобы перехватить раньше тильды/всплытия до menu
      openBtns.forEach(btn => btn.addEventListener('click', open, { capture: true }));
      Core.qsa(cfg.closeBtnSel).forEach(btn => btn.addEventListener('click', close, { capture: true }));

      // backdrop
      menu.addEventListener('click', onMenuClick);

      // links
      (panel || menu).addEventListener('click', onLink);

      document.addEventListener('keydown', onKey);

      burgerMap.set(menu, { open, close });
    }
  };

  // ===== submenu (0.4.4 logic: never close while :hover is true) =====
  const submenuMap = new WeakMap();
  const submenu = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({
        headerSel: '.uc-header',
        triggerSel: '.submenu',
        panelSel: '.uc-submenu',
        panelInnerSel: '.submenu-panel',

        openClass: 'is-open',
        activeClass: 'is-active',

        mode: 'mixed',
        desktopBp: 1200,
        mixedClickThrough: true,

        closeDelay: 200,
        closeOnOutside: false,
        closeOnEsc: true,

        doubleTapWindow: 2000,
        overlay: true,
        closeOnScroll: true
      }, p);

      const headerRaw = Core.qs(cfg.headerSel);
      const header = Core.asRec(headerRaw) || headerRaw;
      if (!header) return;

      const state = submenuMap.get(header) || {
        pairs: [],
        docBound: false,
        closeTimer: null,
        lastTapIdx: -1,
        lastTapAt: 0,
        closeAll: null
      };

      if (cfg.overlay) document.documentElement.classList.add('mod-submenu-overlay');

      const scan = () => {
        const triggers = Core.qsa(cfg.triggerSel, header);

        const panelsRaw = Core.qsa(cfg.panelSel, document);
        const seen = new Set();
        const panels = [];
        panelsRaw.forEach(el => {
          const rec = Core.asRec(el);
          if (!rec) return;
          if (!rec.classList.contains('uc-submenu')) rec.classList.add('uc-submenu');
          if (seen.has(rec)) return;
          seen.add(rec);
          panels.push(rec);
        });

        const n = Math.min(triggers.length, panels.length);
        if (!n) return;

        const pairs = [];
        for (let i = 0; i < n; i++) {
          const pWrap = panels[i];
          const pInner = Core.qs(cfg.panelInnerSel, pWrap) || pWrap;
          pairs.push({ t: triggers[i], pWrap, pInner, i });
        }
        state.pairs = pairs;

        const isDesktop = () => Core.isDesktop(cfg.desktopBp);
        const shouldHover = () => cfg.mode === 'hover' || (cfg.mode === 'mixed' && isDesktop());

        const isHoveringAny = () => {
          try {
            return state.pairs.some(({ t, pWrap, pInner }) =>
              (t && t.matches && t.matches(':hover')) ||
              (pWrap && pWrap.matches && pWrap.matches(':hover')) ||
              (pInner && pInner.matches && pInner.matches(':hover'))
            );
          } catch { return false; }
        };

        const closeAll = () => {
          clearTimeout(state.closeTimer);
          state.closeTimer = null;

          state.lastTapIdx = -1;
          state.lastTapAt = 0;
          state.pairs.forEach(({ t, pWrap }) => {
            t.classList.remove(cfg.activeClass);
            pWrap.classList.remove(cfg.openClass);
            t.setAttribute('aria-expanded', 'false');
          });
        };
        state.closeAll = closeAll;

        const openOnly = (idx) => {
          state.pairs.forEach(({ t, pWrap, i }) => {
            const on = i === idx;
            t.classList.toggle(cfg.activeClass, on);
            pWrap.classList.toggle(cfg.openClass, on);
            t.setAttribute('aria-expanded', on ? 'true' : 'false');
          });
        };

        const scheduleClose = () => {
          clearTimeout(state.closeTimer);
          state.closeTimer = setTimeout(() => {
            if (isHoveringAny()) { scheduleClose(); return; }
            closeAll();
          }, cfg.closeDelay);
        };

        const cancelClose = () => {
          clearTimeout(state.closeTimer);
          state.closeTimer = null;
        };

        pairs.forEach(({ t, pWrap, pInner, i }) => {
          if (t.dataset.modsSubmenuBound === '1') return;
          t.dataset.modsSubmenuBound = '1';

          t.setAttribute('aria-haspopup', 'true');
          t.setAttribute('aria-expanded', 'false');

          t.addEventListener('mouseenter', () => { if (shouldHover()) { cancelClose(); openOnly(i); } });
          t.addEventListener('mouseleave', () => { if (shouldHover()) scheduleClose(); });

          pWrap.addEventListener('mouseenter', () => { if (shouldHover()) cancelClose(); });
          pWrap.addEventListener('mouseleave', () => { if (shouldHover()) scheduleClose(); });
          pInner.addEventListener('mouseenter', () => { if (shouldHover()) cancelClose(); });
          pInner.addEventListener('mouseleave', () => { if (shouldHover()) scheduleClose(); });

          const onClickT = (e) => {
            if (cfg.mode === 'mixed' && isDesktop() && cfg.mixedClickThrough) return;

            const now = Date.now();
            const isOpen = pWrap.classList.contains(cfg.openClass);

            if (isOpen && state.lastTapIdx === i && (now - state.lastTapAt) <= cfg.doubleTapWindow) {
              state.lastTapIdx = -1; state.lastTapAt = 0;
              return;
            }

            e.preventDefault();
            openOnly(i);
            state.lastTapIdx = i;
            state.lastTapAt = now;
          };
          t.addEventListener('click', onClickT);

          const onClickWrap = (e) => {
            if (!pWrap.classList.contains(cfg.openClass)) return;
            if (pInner && pInner.contains(e.target)) return;
            closeAll();
          };
          pWrap.addEventListener('click', onClickWrap);
        });

        closeAll();
      };

      scan();

      if (!state.docBound) {
        state.docBound = true;

        const onDocClick = (e) => {
          if (!cfg.closeOnOutside || !state.closeAll) return;
          const inside = state.pairs.some(({ t, pInner }) => t.contains(e.target) || (pInner && pInner.contains(e.target)));
          if (!inside) state.closeAll();
        };

        const onKey = (e) => {
          if (!cfg.closeOnEsc || !state.closeAll) return;
          if (e.key === 'Escape') state.closeAll();
        };

        document.addEventListener('click', onDocClick);
        document.addEventListener('keydown', onKey);

        if (cfg.closeOnScroll) {
          window.addEventListener('scroll', Core.throttle(() => { if (state.closeAll) state.closeAll(); }, 140), { passive: true });
        }
        window.addEventListener('resize', Core.throttle(() => { if (state.closeAll) state.closeAll(); }, 200));
      }

      submenuMap.set(header, state);
    }
  };

  // ===== widgetMove =====
  const widgetMove = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({ items: [], mode: 'append', observe: true }, p);

      const apply = () => {
        (cfg.items || []).forEach(item => {
          const fromSel = item.from, toSel = item.to;
          const mode = item.mode || cfg.mode;
          if (!fromSel || !toSel) return;

          Core.whenBothExist(fromSel, toSel, (fromEl, toEl) => {
            if (toEl.contains(fromEl)) return;
            if (mode === 'replace') { toEl.innerHTML = ''; toEl.appendChild(fromEl); }
            else if (mode === 'prepend') { toEl.insertBefore(fromEl, toEl.firstChild); }
            else { toEl.appendChild(fromEl); }
          });
        });
      };

      apply();
      if (cfg.observe) Core.observe(apply);
    }
  };

  // ===== activePage =====
  const activePage = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({
        containers: ['.uc-header', '.uc-menu'],
        pageSel: '.page',
        pageElemSel: '.page-elem',
        activeClass: 'is-active',
        linkActiveClass: 'is-active'
      }, p);

      const run = () => {
        const cur = (location.pathname || '/').replace(/\/$/, '') || '/';

        cfg.containers.forEach(sel => {
          const box = Core.qs(sel);
          if (!box) return;

          const pages = Core.qsa(cfg.pageSel, box);
          if (pages.length) {
            pages.forEach(page => {
              const link = page.matches('a[href]') ? page : Core.qs('a[href]', page);
              const href = link ? link.getAttribute('href') : null;
              const norm = href ? Core.normPath(href) : null;
              const isActive = norm && norm === cur;

              page.classList.toggle(cfg.activeClass, !!isActive);
              if (link) link.classList.toggle(cfg.linkActiveClass, !!isActive);

              const deco = Core.qs(cfg.pageElemSel, page);
              if (deco) deco.classList.toggle(cfg.activeClass, !!isActive);
            });
            return;
          }

          Core.qsa('a[href]', box).forEach(a => {
            const href = a.getAttribute('href');
            const norm = href ? Core.normPath(href) : null;
            a.classList.toggle(cfg.linkActiveClass, !!(norm && norm === cur));
          });
        });
      };

      run();
      w.addEventListener('popstate', run);
    }
  };

  const MyMods = w.MyMods || {};
  MyMods.version = '0.4.5';

  MyMods.Core = Core;
  MyMods.Tilda = Tilda;

  MyMods.resetUIState = resetUIState;

  MyMods.stickyHeader = stickyHeader;
  MyMods.burgerMenu = burgerMenu;
  MyMods.submenu = submenu;
  MyMods.widgetMove = widgetMove;
  MyMods.activePage = activePage;

  MyMods.init = (rootSel, config = {}) => {
    // ✅ FIX: не даём повторным init (MutationObserver) закрывать меню/сабменю, если они уже открыты
    const html = document.documentElement;
    const menuOpen = html.classList.contains('is-menu-open');
    const submenuOpen = !!document.querySelector('.t-rec.uc-submenu.is-open, .uc-submenu.is-open');
    if (!menuOpen && !submenuOpen) resetUIState();

    if (config.stickyHeader) MyMods.stickyHeader.init(rootSel, config.stickyHeader);
    if (config.burgerMenu)   MyMods.burgerMenu.init(rootSel, config.burgerMenu);
    if (config.submenu)      MyMods.submenu.init(rootSel, config.submenu);
    if (config.widgetMove)   MyMods.widgetMove.init(rootSel, config.widgetMove);
    if (config.activePage)   MyMods.activePage.init(rootSel, config.activePage);

    if (!MyMods.__logged) {
      MyMods.__logged = true;
      console.log('[MyMods] init ok, version', MyMods.version);
    }
  };

  w.MyMods = MyMods;
  console.log('[MyMods] library loaded, version', MyMods.version);

})(window);
