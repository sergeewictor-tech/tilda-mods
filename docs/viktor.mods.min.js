(function (w) {
  'use strict';

  const Core = {};
  Core.qs  = (s, r = document) => r.querySelector(s);
  Core.qsa = (s, r = document) => Array.from(r.querySelectorAll(s));

  Core.ready = (fn) => {
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn, { once: true });
    else fn();
  };

  Core.throttle = (fn, wait = 80) => {
    let last = 0, t = null;
    return (...args) => {
      const now = Date.now();
      const rem = wait - (now - last);
      if (rem <= 0) { last = now; fn(...args); }
      else if (!t) t = setTimeout(() => { t = null; last = Date.now(); fn(...args); }, rem);
    };
  };

  Core.lockScroll = () => {
    const html = document.documentElement;
    if (html.classList.contains('mod-scroll-locked')) return;
    const sbw = w.innerWidth - html.clientWidth;
    html.style.setProperty('--mod-scrollbar-w', sbw + 'px');
    html.classList.add('mod-scroll-locked');
  };

  Core.unlockScroll = () => {
    const html = document.documentElement;
    html.classList.remove('mod-scroll-locked');
    html.style.removeProperty('--mod-scrollbar-w');
  };

  Core.observe = (cb, root = document.body) => {
    const mo = new MutationObserver((m) => {
      if (m.some(x => x.addedNodes && x.addedNodes.length)) cb(m);
    });
    mo.observe(root, { childList: true, subtree: true });
    return () => mo.disconnect();
  };

  Core.whenBothExist = (fromSel, toSel, cb, { timeout = 12000, poll = 120 } = {}) => {
    const start = Date.now();
    (function tick() {
      const a = Core.qs(fromSel), b = Core.qs(toSel);
      if (a && b) return cb(a, b);
      if (Date.now() - start > timeout) return;
      setTimeout(tick, poll);
    })();
  };

  Core.isDesktop = (bp = 980) => w.innerWidth >= bp;

  Core.normPath = (url) => {
    try {
      const u = new URL(url, location.origin);
      let p = u.pathname.replace(/\/$/, '');
      if (p === '') p = '/';
      return p;
    } catch { return null; }
  };

  // Tilda: prefer working with t-rec
  Core.asRec = (el) => {
    if (!el) return null;
    if (el.classList && el.classList.contains('t-rec')) return el;
    return el.closest ? (el.closest('.t-rec') || el) : el;
  };

  const Tilda = {};
  Tilda.mount = (fn, { observe = true, throttle = 120 } = {}) => {
    const run = Core.throttle(fn, throttle);
    Core.ready(run);
    w.addEventListener('load', run);
    const off = observe ? Core.observe(() => run()) : () => {};
    return () => off();
  };

  // ===== Global hard reset =====
  const resetUIState = () => {
    const html = document.documentElement;
    html.classList.remove('is-menu-open');
    Core.unlockScroll();

    Core.qsa('.t-rec.uc-menu.is-open, .uc-menu.is-open').forEach(m => m.classList.remove('is-open'));
    Core.qsa('.t-rec.uc-submenu.is-open, .uc-submenu.is-open').forEach(s => s.classList.remove('is-open'));
    Core.qsa('.uc-header .submenu.is-active').forEach(t => {
      t.classList.remove('is-active');
      t.setAttribute('aria-expanded', 'false');
    });
  };

  // ===== stickyHeader (+ hide on scroll) =====
  const stickyMap = new WeakMap();
  const stickyHeader = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({
        headerSel: '.uc-header',
        scrolledClass: 'is-scrolled',
        threshold: 10,
        setHeaderHeightVar: true,
        headerHeightVarName: '--mods-header-h',

        hideOnScroll: false,
        hideTargetSel: '.header-shell',
        hideClass: 'is-hidden',
        hideMinY: 120,
        hideDelta: 10
      }, p);

      const headerRaw = Core.qs(cfg.headerSel);
      const header = Core.asRec(headerRaw) || headerRaw;
      if (!header) return;
      if (stickyMap.has(header)) return;

      const hideTarget =
        Core.qs(cfg.hideTargetSel, header) ||
        Core.qs(cfg.hideTargetSel) ||
        header;

      const updateHeaderVar = () => {
        if (!cfg.setHeaderHeightVar) return;
        const h = Math.round(header.getBoundingClientRect().height);
        if (h > 0) document.documentElement.style.setProperty(cfg.headerHeightVarName, h + 'px');
      };

      let lastY = w.scrollY || 0;

      const onScroll = Core.throttle(() => {
        const y = w.scrollY || document.documentElement.scrollTop || 0;

        header.classList.toggle(cfg.scrolledClass, y > cfg.threshold);

        if (cfg.hideOnScroll) {
          const html = document.documentElement;
          const menuOpen = html.classList.contains('is-menu-open');
          const submenuOpen = !!document.querySelector('.t-rec.uc-submenu.is-open, .uc-submenu.is-open');

          if (menuOpen || submenuOpen || y < cfg.hideMinY) {
            hideTarget.classList.remove(cfg.hideClass);
            lastY = y;
            return;
          }

          const diff = y - lastY;
          if (Math.abs(diff) < cfg.hideDelta) return;

          if (diff > 0) hideTarget.classList.add(cfg.hideClass);
          else hideTarget.classList.remove(cfg.hideClass);

          lastY = y;
        }
      }, 60);

      const onResize = Core.throttle(() => updateHeaderVar(), 120);

      w.addEventListener('scroll', onScroll, { passive: true });
      w.addEventListener('resize', onResize);

      onScroll();
      updateHeaderVar();

      stickyMap.set(header, { onScroll, onResize });
    }
  };

  // ===== burgerMenu =====
  const burgerMap = new WeakMap();
  const burgerMenu = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({
        menuSel: '.uc-menu',
        panelSel: '.menu-panel',
        openBtnSel: '.js-menu-open',
        closeBtnSel: '.js-menu-close',
        openClassMenu: 'is-open',
        openClassHtml: 'is-menu-open',
        closeOnEsc: true,
        closeOnBackdropClick: true,
        closeOnLinkClick: true,
        linkSel: 'a[href]',
        justOpenedIgnoreMs: 250,

        // вот они — твои слоты виджетов
        widgetMoonSel: '.widget-slot-moon',
        widgetHolidaySel: '.widget-slot-holiday'
      }, p);

      const menuRaw = Core.qs(cfg.menuSel);
      if (!menuRaw) return;

      const menu = Core.asRec(menuRaw);
      if (!menu.classList.contains('uc-menu')) menu.classList.add('uc-menu');

      const openBtns = Core.qsa(cfg.openBtnSel);
      if (!openBtns.length) return;

      if (burgerMap.has(menu)) return;

      const panel = Core.qs(cfg.panelSel, menu);

      let isOpen = false;
      let openedAt = 0;

      // ===== helpers =====
      const isWidgetClick = (target) => {
        if (!target || !target.closest) return false;
        return !!target.closest(cfg.widgetMoonSel + ',' + cfg.widgetHolidaySel);
      };
      const widgetKeyFromTarget = (target) => {
        const el = target.closest(cfg.widgetMoonSel + ',' + cfg.widgetHolidaySel);
        if (!el) return null;
        return el.matches(cfg.widgetMoonSel) ? 'moon' : 'holiday';
      };

      const killEvent = (e) => {
        if (!e) return;
        if (e.preventDefault) e.preventDefault();
        if (e.stopPropagation) e.stopPropagation();
        if (e.stopImmediatePropagation) e.stopImmediatePropagation();
      };

      const tooSoonAfterOpen = () => (Date.now() - openedAt) < cfg.justOpenedIgnoreMs;

      // ===== Popup “pin” engine (no IDs needed) =====
      const pinned = new WeakMap(); // el -> state
      const widgetPop = { moon: null, holiday: null };
      const widgetPopAttrMO = { moon: null, holiday: null };

      const isVisible = (el) => {
        if (!el) return false;
        let cs;
        try { cs = getComputedStyle(el); } catch { return false; }
        if (cs.display === 'none') return false;
        if (cs.visibility === 'hidden') return false;
        const op = parseFloat(cs.opacity);
        if (!isNaN(op) && op <= 0.01) return false;
        if (el.offsetWidth === 0 && el.offsetHeight === 0) return false;
        return true;
      };

      const rectOffscreen = (r) => {
        const vh = w.innerHeight || document.documentElement.clientHeight || 0;
        const vw = w.innerWidth  || document.documentElement.clientWidth  || 0;
        return (r.top < 0 || r.left < 0 || r.bottom > vh || r.right > vw);
      };

      const pinToViewport = (el) => {
        if (!el) return;

        if (!pinned.has(el)) {
          pinned.set(el, {
            parent: el.parentNode,
            next: el.nextSibling,
            style: {
              position: el.style.position,
              top: el.style.top,
              left: el.style.left,
              right: el.style.right,
              bottom: el.style.bottom,
              transform: el.style.transform,
              maxHeight: el.style.maxHeight,
              maxWidth: el.style.maxWidth,
              overflow: el.style.overflow,
              zIndex: el.style.zIndex
            }
          });
        }

        // выносим в body (устраняет “fixed внутри transform-контейнера”)
        if (el.parentNode !== document.body) document.body.appendChild(el);

        // IMPORTANT через setProperty(!important), чтобы перебить inline из виджета
        el.style.setProperty('position', 'fixed', 'important');
        el.style.setProperty('top', '50%', 'important');
        el.style.setProperty('left', '50%', 'important');
        el.style.setProperty('right', 'auto', 'important');
        el.style.setProperty('bottom', 'auto', 'important');
        el.style.setProperty('transform', 'translate(-50%, -50%)', 'important');
        el.style.setProperty('max-height', 'calc(100vh - 24px)', 'important');
        el.style.setProperty('max-width',  'calc(100vw - 24px)', 'important');
        el.style.setProperty('overflow', 'auto', 'important');

        let z = 0;
        try { z = parseInt(getComputedStyle(el).zIndex, 10) || 0; } catch {}
        el.style.setProperty('z-index', String(Math.max(z, 10060)), 'important');
      };

      const unpin = (el) => {
        const st = pinned.get(el);
        if (!st) return;

        // restore inline styles (без important — как было)
        el.style.position = st.style.position;
        el.style.top = st.style.top;
        el.style.left = st.style.left;
        el.style.right = st.style.right;
        el.style.bottom = st.style.bottom;
        el.style.transform = st.style.transform;
        el.style.maxHeight = st.style.maxHeight;
        el.style.maxWidth  = st.style.maxWidth;
        el.style.overflow  = st.style.overflow;
        el.style.zIndex    = st.style.zIndex;

        // restore DOM position
        try {
          if (st.parent && st.parent.nodeType === 1) {
            if (st.next && st.next.parentNode === st.parent) st.parent.insertBefore(el, st.next);
            else st.parent.appendChild(el);
          }
        } catch {}

        pinned.delete(el);
      };

      const maybePinIfOffscreen = (el) => {
        if (!isOpen) return;
        if (!el) return;
        if (!isVisible(el)) return;

        const r = el.getBoundingClientRect();
        if (rectOffscreen(r)) pinToViewport(el);
      };

      const bindAttrObserver = (key, el) => {
        if (!el) return;
        if (widgetPopAttrMO[key]) {
          try { widgetPopAttrMO[key].disconnect(); } catch {}
          widgetPopAttrMO[key] = null;
        }
        const mo = new MutationObserver(() => {
          if (!isOpen) return;
          // на показ/анимацию — пару тиков
          setTimeout(() => maybePinIfOffscreen(el), 0);
          setTimeout(() => maybePinIfOffscreen(el), 80);
          setTimeout(() => maybePinIfOffscreen(el), 200);
        });
        mo.observe(el, { attributes: true, attributeFilter: ['class','style'] });
        widgetPopAttrMO[key] = mo;
      };

      // “умный ловец” — ищем попап именно после клика по слоту
      const capturePopupAfterWidgetClick = (key) => {
        if (!key) return;

        const collected = new Set();
        const start = Date.now();

        const score = (el) => {
          // приоритет: mods-pop (у праздников точно), затем высокий z-index и размер
          let s = 0;
          if (!el || el.nodeType !== 1) return -1;
          const id = (el.id || '').toLowerCase();
          const cls = ('' + (el.className || '')).toLowerCase();

          if (cls.includes('mods-pop')) s += 1000;
          if (id.includes('wicca')) s += 900;
          if (id.includes('moon')) s += 400;

          let cs;
          try { cs = getComputedStyle(el); } catch { return -1; }
          const z = parseInt(cs.zIndex, 10) || 0;
          if (z > 0) s += Math.min(600, z / 10);

          const r = el.getBoundingClientRect();
          s += Math.min(500, (r.width * r.height) / 600);

          if (cs.position === 'fixed') s += 120;
          if (cs.position === 'absolute') s += 60;

          return s;
        };

        const consider = (el) => {
          if (!el || el.nodeType !== 1) return;
          if (!isVisible(el)) return;

          // не считаем меню/сабменю попапом
          if (el.closest && el.closest('.uc-menu, .uc-submenu, .uc-header')) return;

          // быстрые фильтры по разумным размерам
          const r = el.getBoundingClientRect();
          if (r.width < 120 || r.height < 50) return;

          collected.add(el);
        };

        // MO на 700мс — ловим добавления/переключения
        const mo = new MutationObserver((muts) => {
          if (!isOpen) return;
          for (const m of muts) {
            if (m.type === 'childList') {
              m.addedNodes && m.addedNodes.forEach(n => {
                if (!n || n.nodeType !== 1) return;
                consider(n);
                // и детей (ограниченно)
                const kids = n.querySelectorAll ? n.querySelectorAll('*') : [];
                for (let i = 0; i < Math.min(kids.length, 40); i++) consider(kids[i]);
              });
            } else if (m.type === 'attributes') {
              consider(m.target);
            }
          }
        });

        mo.observe(document.body, {
          subtree: true,
          childList: true,
          attributes: true,
          attributeFilter: ['class','style']
        });

        // дополнительно: быстрый прямой скан известных паттернов
        const quickScan = () => {
          Core.qsa('.mods-pop, #wicca-pop, .t-popup, .t-popup_show, .t-popup__container').forEach(consider);
        };

        setTimeout(quickScan, 50);
        setTimeout(quickScan, 180);
        setTimeout(quickScan, 360);

        setTimeout(() => {
          try { mo.disconnect(); } catch {}

          if (!isOpen) return;

          // выбираем лучший кандидат
          let best = null;
          let bestS = -1;
          collected.forEach(el => {
            const s = score(el);
            if (s > bestS) { bestS = s; best = el; }
          });

          if (best) {
            widgetPop[key] = best;
            bindAttrObserver(key, best);
            // если он улетел вверх — пин
            maybePinIfOffscreen(best);
          } else {
            // если не поймали — ничего не ломаем
            widgetPop[key] = widgetPop[key] || null;
          }

        }, Math.max(700 - (Date.now() - start), 120));
      };

      const tryCloseAnyOpenPopups = () => {
        // 1) клик по кнопке закрытия внутри известных попапов
        ['moon','holiday'].forEach(k => {
          const el = widgetPop[k];
          if (!el) return;
          if (!isVisible(el)) return;
          const btn = el.querySelector('.t-popup__close, .close, .popup-close, [data-close], [aria-label="Close"], [aria-label="Закрыть"]');
          if (btn && btn.click) {
            try { btn.click(); } catch {}
          }
        });

        // 2) “outside click” — чтобы виджеты сами закрыли поповер
        try {
          document.body.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, cancelable: true, clientX: 2, clientY: 2 }));
          document.body.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true, clientX: 2, clientY: 2 }));
        } catch {}
      };

      // ===== open / close =====
      const open = (e) => {
        killEvent(e);
        if (isOpen) return;

        isOpen = true;
        openedAt = Date.now();

        // закрываем сабменю, если было открыто
        Core.qsa('.t-rec.uc-submenu.is-open, .uc-submenu.is-open').forEach(s => s.classList.remove('is-open'));
        Core.qsa('.uc-header .submenu.is-active').forEach(t => {
          t.classList.remove('is-active');
          t.setAttribute('aria-expanded', 'false');
        });

        // если что-то “залипло” с прошлого раза — закрываем
        tryCloseAnyOpenPopups();

        menu.classList.add(cfg.openClassMenu);
        document.documentElement.classList.add(cfg.openClassHtml);
      };

      const close = (e, { kill = false } = {}) => {
        // КЛЮЧ: по фону не глушим событие (поповеры должны получить outside click)
        if (kill) killEvent(e);

        if (!isOpen) return;
        isOpen = false;

        menu.classList.remove(cfg.openClassMenu);
        document.documentElement.classList.remove(cfg.openClassHtml);

        // дать виджетам шанс закрыться по outside click
        setTimeout(() => tryCloseAnyOpenPopups(), 0);

        // откатываем пины (чтобы не было “висящих попапов”)
        ['moon','holiday'].forEach(k => {
          const el = widgetPop[k];
          if (el) unpin(el);
        });
      };

      // ===== backdrop / links =====
      const isBackdropTarget = (target) => {
        if (!target) return false;
        if (target === menu) return true;
        if (target.closest) {
          if (target.closest('.t396__carrier, .t396__filter')) return true;
        }
        return false;
      };

      const onMenuClick = (e) => {
        if (!cfg.closeOnBackdropClick || !isOpen) return;
        if (tooSoonAfterOpen()) return;

        // 0) клики по виджетам — НИКОГДА не закрывают меню
        if (isWidgetClick(e.target)) return;

        // 1) игнор по кнопкам
        if (e.target.closest(cfg.openBtnSel) || e.target.closest(cfg.closeBtnSel)) return;

        // 2) клик внутри панели — не закрываем
        if (panel && panel.contains(e.target)) return;

        // 3) закрываем только по реальному фону
        if (!isBackdropTarget(e.target)) return;

        close(); // без killEvent!
      };

      const onKey = (e) => {
        if (!cfg.closeOnEsc) return;
        if (e.key === 'Escape') close();
      };

      const onLink = (e) => {
        if (!cfg.closeOnLinkClick || !isOpen) return;
        if (tooSoonAfterOpen()) return;

        const a = e.target.closest(cfg.linkSel);
        if (!a) return;

        // ссылки внутри виджет-слотов не должны закрывать меню
        if (isWidgetClick(a)) return;

        close(); // закрываем без убийства клика, чтобы переход по ссылке работал
      };

      // ===== widget click: capture popup =====
      const onAnyClickInMenu = (e) => {
        if (!isOpen) return;
        if (tooSoonAfterOpen()) return;

        if (!isWidgetClick(e.target)) return;

        const key = widgetKeyFromTarget(e.target);
        if (!key) return;

        // не даём этому клику считаться бекдропом + ловим попап
        capturePopupAfterWidgetClick(key);
      };

      // listeners
      openBtns.forEach(btn => btn.addEventListener('click', open, { capture: true }));
      Core.qsa(cfg.closeBtnSel).forEach(btn => btn.addEventListener('click', (e) => close(e, { kill: true }), { capture: true }));

      menu.addEventListener('click', onMenuClick);
      menu.addEventListener('click', onLink, true);
      menu.addEventListener('click', onAnyClickInMenu, true);

      document.addEventListener('keydown', onKey);

      burgerMap.set(menu, { open, close });
    }
  };

  // ===== submenu (0.4.4 logic: never close while :hover is true) =====
  const submenuMap = new WeakMap();
  const submenu = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({
        headerSel: '.uc-header',
        triggerSel: '.submenu',
        panelSel: '.uc-submenu',
        panelInnerSel: '.submenu-panel',

        openClass: 'is-open',
        activeClass: 'is-active',

        mode: 'mixed',
        desktopBp: 1200,
        mixedClickThrough: true,

        closeDelay: 200,
        closeOnOutside: false,
        closeOnEsc: true,

        doubleTapWindow: 2000,
        overlay: true,
        closeOnScroll: true
      }, p);

      const headerRaw = Core.qs(cfg.headerSel);
      const header = Core.asRec(headerRaw) || headerRaw;
      if (!header) return;

      const state = submenuMap.get(header) || {
        pairs: [],
        docBound: false,
        closeTimer: null,
        lastTapIdx: -1,
        lastTapAt: 0,
        closeAll: null
      };

      if (cfg.overlay) document.documentElement.classList.add('mod-submenu-overlay');

      const scan = () => {
        const triggers = Core.qsa(cfg.triggerSel, header);

        const panelsRaw = Core.qsa(cfg.panelSel, document);
        const seen = new Set();
        const panels = [];
        panelsRaw.forEach(el => {
          const rec = Core.asRec(el);
          if (!rec) return;
          if (!rec.classList.contains('uc-submenu')) rec.classList.add('uc-submenu');
          if (seen.has(rec)) return;
          seen.add(rec);
          panels.push(rec);
        });

        const n = Math.min(triggers.length, panels.length);
        if (!n) return;

        const pairs = [];
        for (let i = 0; i < n; i++) {
          const pWrap = panels[i];
          const pInner = Core.qs(cfg.panelInnerSel, pWrap) || pWrap;
          pairs.push({ t: triggers[i], pWrap, pInner, i });
        }
        state.pairs = pairs;

        const isDesktop = () => Core.isDesktop(cfg.desktopBp);
        const shouldHover = () => cfg.mode === 'hover' || (cfg.mode === 'mixed' && isDesktop());

        const isHoveringAny = () => {
          try {
            return state.pairs.some(({ t, pWrap, pInner }) =>
              (t && t.matches && t.matches(':hover')) ||
              (pWrap && pWrap.matches && pWrap.matches(':hover')) ||
              (pInner && pInner.matches && pInner.matches(':hover'))
            );
          } catch { return false; }
        };

        const closeAll = () => {
          clearTimeout(state.closeTimer);
          state.closeTimer = null;

          state.lastTapIdx = -1;
          state.lastTapAt = 0;
          state.pairs.forEach(({ t, pWrap }) => {
            t.classList.remove(cfg.activeClass);
            pWrap.classList.remove(cfg.openClass);
            t.setAttribute('aria-expanded', 'false');
          });
        };
        state.closeAll = closeAll;

        const openOnly = (idx) => {
          state.pairs.forEach(({ t, pWrap, i }) => {
            const on = i === idx;
            t.classList.toggle(cfg.activeClass, on);
            pWrap.classList.toggle(cfg.openClass, on);
            t.setAttribute('aria-expanded', on ? 'true' : 'false');
          });
        };

        const scheduleClose = () => {
          clearTimeout(state.closeTimer);
          state.closeTimer = setTimeout(() => {
            if (isHoveringAny()) { scheduleClose(); return; }
            closeAll();
          }, cfg.closeDelay);
        };

        const cancelClose = () => {
          clearTimeout(state.closeTimer);
          state.closeTimer = null;
        };

        pairs.forEach(({ t, pWrap, pInner, i }) => {
          if (t.dataset.modsSubmenuBound === '1') return;
          t.dataset.modsSubmenuBound = '1';

          t.setAttribute('aria-haspopup', 'true');
          t.setAttribute('aria-expanded', 'false');

          t.addEventListener('mouseenter', () => { if (shouldHover()) { cancelClose(); openOnly(i); } });
          t.addEventListener('mouseleave', () => { if (shouldHover()) scheduleClose(); });

          pWrap.addEventListener('mouseenter', () => { if (shouldHover()) cancelClose(); });
          pWrap.addEventListener('mouseleave', () => { if (shouldHover()) scheduleClose(); });
          pInner.addEventListener('mouseenter', () => { if (shouldHover()) cancelClose(); });
          pInner.addEventListener('mouseleave', () => { if (shouldHover()) scheduleClose(); });

          const onClickT = (e) => {
            if (cfg.mode === 'mixed' && isDesktop() && cfg.mixedClickThrough) return;

            const now = Date.now();
            const isOpen = pWrap.classList.contains(cfg.openClass);

            if (isOpen && state.lastTapIdx === i && (now - state.lastTapAt) <= cfg.doubleTapWindow) {
              state.lastTapIdx = -1; state.lastTapAt = 0;
              return;
            }

            e.preventDefault();
            openOnly(i);
            state.lastTapIdx = i;
            state.lastTapAt = now;
          };
          t.addEventListener('click', onClickT);

          const onClickWrap = (e) => {
            if (!pWrap.classList.contains(cfg.openClass)) return;
            if (pInner && pInner.contains(e.target)) return;
            closeAll();
          };
          pWrap.addEventListener('click', onClickWrap);
        });

        closeAll();
      };

      scan();

      if (!state.docBound) {
        state.docBound = true;

        const onDocClick = (e) => {
          if (!cfg.closeOnOutside || !state.closeAll) return;
          const inside = state.pairs.some(({ t, pInner }) => t.contains(e.target) || (pInner && pInner.contains(e.target)));
          if (!inside) state.closeAll();
        };

        const onKey = (e) => {
          if (!cfg.closeOnEsc || !state.closeAll) return;
          if (e.key === 'Escape') state.closeAll();
        };

        document.addEventListener('click', onDocClick);
        document.addEventListener('keydown', onKey);

        if (cfg.closeOnScroll) {
          window.addEventListener('scroll', Core.throttle(() => { if (state.closeAll) state.closeAll(); }, 140), { passive: true });
        }
        window.addEventListener('resize', Core.throttle(() => { if (state.closeAll) state.closeAll(); }, 200));
      }

      submenuMap.set(header, state);
    }
  };

  // ===== widgetMove =====
  const widgetMove = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({ items: [], mode: 'append', observe: true }, p);

      const apply = () => {
        (cfg.items || []).forEach(item => {
          const fromSel = item.from, toSel = item.to;
          const mode = item.mode || cfg.mode;
          if (!fromSel || !toSel) return;

          Core.whenBothExist(fromSel, toSel, (fromEl, toEl) => {
            if (toEl.contains(fromEl)) return;
            if (mode === 'replace') { toEl.innerHTML = ''; toEl.appendChild(fromEl); }
            else if (mode === 'prepend') { toEl.insertBefore(fromEl, toEl.firstChild); }
            else { toEl.appendChild(fromEl); }
          });
        });
      };

      apply();
      if (cfg.observe) Core.observe(apply);
    }
  };

  // ===== activePage =====
  const activePage = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({
        containers: ['.uc-header', '.uc-menu'],
        pageSel: '.page',
        pageElemSel: '.page-elem',
        activeClass: 'is-active',
        linkActiveClass: 'is-active'
      }, p);

      const run = () => {
        const cur = (location.pathname || '/').replace(/\/$/, '') || '/';

        cfg.containers.forEach(sel => {
          const box = Core.qs(sel);
          if (!box) return;

          const pages = Core.qsa(cfg.pageSel, box);
          if (pages.length) {
            pages.forEach(page => {
              const link = page.matches('a[href]') ? page : Core.qs('a[href]', page);
              const href = link ? link.getAttribute('href') : null;
              const norm = href ? Core.normPath(href) : null;
              const isActive = norm && norm === cur;

              page.classList.toggle(cfg.activeClass, !!isActive);
              if (link) link.classList.toggle(cfg.linkActiveClass, !!isActive);

              const deco = Core.qs(cfg.pageElemSel, page);
              if (deco) deco.classList.toggle(cfg.activeClass, !!isActive);
            });
            return;
          }

          Core.qsa('a[href]', box).forEach(a => {
            const href = a.getAttribute('href');
            const norm = href ? Core.normPath(href) : null;
            a.classList.toggle(cfg.linkActiveClass, !!(norm && norm === cur));
          });
        });
      };

      run();
      w.addEventListener('popstate', run);
    }
  };

  const MyMods = w.MyMods || {};
  MyMods.version = '0.4.8';

  MyMods.Core = Core;
  MyMods.Tilda = Tilda;

  MyMods.resetUIState = resetUIState;

  MyMods.stickyHeader = stickyHeader;
  MyMods.burgerMenu = burgerMenu;
  MyMods.submenu = submenu;
  MyMods.widgetMove = widgetMove;
  MyMods.activePage = activePage;

  MyMods.init = (rootSel, config = {}) => {
    const html = document.documentElement;
    const menuOpen = html.classList.contains('is-menu-open');
    const submenuOpen = !!document.querySelector('.t-rec.uc-submenu.is-open, .uc-submenu.is-open');
    if (!menuOpen && !submenuOpen) resetUIState();

    if (config.stickyHeader) MyMods.stickyHeader.init(rootSel, config.stickyHeader);
    if (config.burgerMenu)   MyMods.burgerMenu.init(rootSel, config.burgerMenu);
    if (config.submenu)      MyMods.submenu.init(rootSel, config.submenu);
    if (config.widgetMove)   MyMods.widgetMove.init(rootSel, config.widgetMove);
    if (config.activePage)   MyMods.activePage.init(rootSel, config.activePage);

    if (!MyMods.__logged) {
      MyMods.__logged = true;
      console.log('[MyMods] init ok, version', MyMods.version);
    }
  };

  w.MyMods = MyMods;
  console.log('[MyMods] library loaded, version', MyMods.version);

})(window);
