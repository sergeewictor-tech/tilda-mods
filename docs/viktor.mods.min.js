(function (w) {
  'use strict';

  const Core = {};
  Core.qs  = (s, r = document) => r.querySelector(s);
  Core.qsa = (s, r = document) => Array.from(r.querySelectorAll(s));

  Core.ready = (fn) => {
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn, { once: true });
    else fn();
  };

  Core.throttle = (fn, wait = 80) => {
    let last = 0, t = null;
    return (...args) => {
      const now = Date.now();
      const rem = wait - (now - last);
      if (rem <= 0) { last = now; fn(...args); }
      else if (!t) t = setTimeout(() => { t = null; last = Date.now(); fn(...args); }, rem);
    };
  };

  Core.lockScroll = () => {
    const html = document.documentElement;
    if (html.classList.contains('mod-scroll-locked')) return;
    const sbw = w.innerWidth - html.clientWidth;
    html.style.setProperty('--mod-scrollbar-w', sbw + 'px');
    html.classList.add('mod-scroll-locked');
  };

  Core.unlockScroll = () => {
    const html = document.documentElement;
    html.classList.remove('mod-scroll-locked');
    html.style.removeProperty('--mod-scrollbar-w');
  };

  Core.observe = (cb, root = document.body) => {
    const mo = new MutationObserver((m) => {
      if (m.some(x => x.addedNodes && x.addedNodes.length)) cb(m);
    });
    mo.observe(root, { childList: true, subtree: true });
    return () => mo.disconnect();
  };

  Core.whenBothExist = (fromSel, toSel, cb, { timeout = 12000, poll = 120 } = {}) => {
    const start = Date.now();
    (function tick() {
      const a = Core.qs(fromSel), b = Core.qs(toSel);
      if (a && b) return cb(a, b);
      if (Date.now() - start > timeout) return;
      setTimeout(tick, poll);
    })();
  };

  Core.isDesktop = (bp = 980) => w.innerWidth >= bp;

  Core.normPath = (url) => {
    try {
      const u = new URL(url, location.origin);
      let p = u.pathname.replace(/\/$/, '');
      if (p === '') p = '/';
      return p;
    } catch { return null; }
  };

  const Tilda = {};
  Tilda.mount = (fn, { observe = true } = {}) => {
    Core.ready(fn);
    w.addEventListener('load', fn);
    const off = observe ? Core.observe(() => fn()) : () => {};
    return () => off();
  };

  // ===== stickyHeader (+ hide on scroll) =====
  const stickyMap = new WeakMap();
  const stickyHeader = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({
        headerSel: '.uc-header',
        scrolledClass: 'is-scrolled',
        threshold: 10,
        setHeaderHeightVar: true,
        headerHeightVarName: '--mods-header-h',

        hideOnScroll: false,
        hideTargetSel: '.header-shell',
        hideClass: 'is-hidden',
        hideMinY: 120,
        hideDelta: 10
      }, p);

      Core.qsa(rootSel || 'body').forEach(root => {
        if (stickyMap.has(root)) return;

        const header = root.matches(cfg.headerSel) ? root : Core.qs(cfg.headerSel, root) || Core.qs(cfg.headerSel);
        if (!header) return;

        const hideTarget = Core.qs(cfg.hideTargetSel, header) || Core.qs(cfg.hideTargetSel) || header;

        const updateHeaderVar = () => {
          if (!cfg.setHeaderHeightVar) return;
          const h = Math.round(header.getBoundingClientRect().height);
          if (h > 0) document.documentElement.style.setProperty(cfg.headerHeightVarName, h + 'px');
        };

        let lastY = w.scrollY || 0;

        const onScroll = Core.throttle(() => {
          const y = w.scrollY || document.documentElement.scrollTop || 0;

          header.classList.toggle(cfg.scrolledClass, y > cfg.threshold);

          if (cfg.hideOnScroll) {
            const html = document.documentElement;
            const menuOpen = html.classList.contains('is-menu-open');
            const submenuOpen = !!document.querySelector('.uc-submenu.is-open');

            if (menuOpen || submenuOpen || y < cfg.hideMinY) {
              hideTarget.classList.remove(cfg.hideClass);
              lastY = y;
              return;
            }

            const diff = y - lastY;
            if (Math.abs(diff) < cfg.hideDelta) return;

            if (diff > 0) hideTarget.classList.add(cfg.hideClass);
            else hideTarget.classList.remove(cfg.hideClass);

            lastY = y;
          }
        }, 60);

        const onResize = Core.throttle(() => updateHeaderVar(), 120);

        w.addEventListener('scroll', onScroll, { passive: true });
        w.addEventListener('resize', onResize);

        onScroll();
        updateHeaderVar();

        stickyMap.set(root, { onScroll, onResize, header, cfg, hideTarget });
      });
    }
  };

  // ===== burgerMenu (close by click outside panel) =====
  const burgerMap = new WeakMap();
  const burgerMenu = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({
        menuSel: '.uc-menu',
        panelSel: '.menu-panel',
        openBtnSel: '.js-menu-open',
        closeBtnSel: '.js-menu-close',
        openClassMenu: 'is-open',
        openClassHtml: 'is-menu-open',
        closeOnEsc: true,
        closeOnBackdropClick: true,
        closeOnLinkClick: true,
        linkSel: 'a[href]'
      }, p);

      Core.qsa(rootSel || 'body').forEach(root => {
        if (burgerMap.has(root)) return;

        const menu = Core.qs(cfg.menuSel) || Core.qs(cfg.menuSel, root);
        const openBtn = Core.qs(cfg.openBtnSel);
        const closeBtn = Core.qs(cfg.closeBtnSel);
        if (!menu || !openBtn) return;

        const panel = Core.qs(cfg.panelSel, menu);
        let isOpen = false;

        const open = (e) => {
          if (e) e.preventDefault();
          if (isOpen) return;
          isOpen = true;
          menu.classList.add(cfg.openClassMenu);
          document.documentElement.classList.add(cfg.openClassHtml);
          Core.lockScroll();
        };

        const close = (e) => {
          if (e && e.preventDefault) e.preventDefault();
          if (!isOpen) return;
          isOpen = false;
          menu.classList.remove(cfg.openClassMenu);
          document.documentElement.classList.remove(cfg.openClassHtml);
          Core.unlockScroll();
        };

        const onMenuClick = (e) => {
          if (!cfg.closeOnBackdropClick || !isOpen) return;
          if (panel && panel.contains(e.target)) return;
          close();
        };

        const onKey = (e) => {
          if (!cfg.closeOnEsc) return;
          if (e.key === 'Escape') close();
        };

        const onLink = (e) => {
          if (!cfg.closeOnLinkClick || !isOpen) return;
          const a = e.target.closest(cfg.linkSel);
          if (!a) return;
          close();
        };

        openBtn.addEventListener('click', open);
        if (closeBtn) closeBtn.addEventListener('click', close);
        menu.addEventListener('click', onMenuClick);
        (panel || menu).addEventListener('click', onLink);
        document.addEventListener('keydown', onKey);

        burgerMap.set(root, { open, close, onMenuClick, onLink, onKey });
      });
    }
  };

  // ===== submenu (hover opens, click navigates on desktop, 2-tap on mobile) =====
  const submenuMap = new WeakMap();
  const submenu = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({
        headerSel: '.uc-header',
        triggerSel: '.submenu',
        panelSel: '.uc-submenu',
        panelInnerSel: '.submenu-panel',

        openClass: 'is-open',
        activeClass: 'is-active',

        mode: 'mixed',
        desktopBp: 980,
        mixedClickThrough: true,

        closeDelay: 160,
        closeOnOutside: true,
        closeOnEsc: true,

        doubleTapWindow: 900,
        overlay: true
      }, p);

      Core.qsa(rootSel || 'body').forEach(root => {
        if (submenuMap.has(root)) return;

        const header = Core.qs(cfg.headerSel, root) || Core.qs(cfg.headerSel);
        if (!header) return;

        const triggers = Core.qsa(cfg.triggerSel, header);
        const panels = Core.qsa(cfg.panelSel, document);
        const n = Math.min(triggers.length, panels.length);
        if (!n) return;

        if (cfg.overlay) document.documentElement.classList.add('mod-submenu-overlay');

        const pairs = [];
        for (let i = 0; i < n; i++) {
          const pWrap = panels[i];
          const pInner = Core.qs(cfg.panelInnerSel, pWrap) || pWrap;
          pairs.push({ t: triggers[i], pWrap, pInner, i });
        }

        let closeTimer = null;
        let lastTapIdx = -1;
        let lastTapAt = 0;

        const isDesktop = () => Core.isDesktop(cfg.desktopBp);
        const shouldHover = () => cfg.mode === 'hover' || (cfg.mode === 'mixed' && isDesktop());

        const closeAll = () => {
          lastTapIdx = -1;
          lastTapAt = 0;
          pairs.forEach(({ t, pWrap }) => {
            t.classList.remove(cfg.activeClass);
            pWrap.classList.remove(cfg.openClass);
            t.setAttribute('aria-expanded', 'false');
          });
        };

        const openOnly = (idx) => {
          pairs.forEach(({ t, pWrap, i }) => {
            const on = i === idx;
            t.classList.toggle(cfg.activeClass, on);
            pWrap.classList.toggle(cfg.openClass, on);
            t.setAttribute('aria-expanded', on ? 'true' : 'false');
          });
        };

        const scheduleClose = () => {
          clearTimeout(closeTimer);
          closeTimer = setTimeout(closeAll, cfg.closeDelay);
        };
        const cancelClose = () => {
          clearTimeout(closeTimer);
          closeTimer = null;
        };

        pairs.forEach(({ t, pWrap, pInner, i }) => {
          t.setAttribute('aria-haspopup', 'true');
          t.setAttribute('aria-expanded', 'false');

          const onEnterT = () => { if (shouldHover()) { cancelClose(); openOnly(i); } };
          const onLeaveT = () => { if (shouldHover()) scheduleClose(); };
          const onEnterP = () => { if (shouldHover()) cancelClose(); };
          const onLeaveP = () => { if (shouldHover()) scheduleClose(); };

          t.addEventListener('mouseenter', onEnterT);
          t.addEventListener('mouseleave', onLeaveT);
          pInner.addEventListener('mouseenter', onEnterP);
          pInner.addEventListener('mouseleave', onLeaveP);

          const onClickT = (e) => {
            if (cfg.mode === 'mixed' && isDesktop() && cfg.mixedClickThrough) return;

            const now = Date.now();
            const isOpen = pWrap.classList.contains(cfg.openClass);

            if (isOpen && lastTapIdx === i && (now - lastTapAt) <= cfg.doubleTapWindow) {
              lastTapIdx = -1; lastTapAt = 0;
              return; // allow navigation
            }

            e.preventDefault();
            openOnly(i);
            lastTapIdx = i;
            lastTapAt = now;
          };

          t.addEventListener('click', onClickT);

          // click in overlay outside panel closes
          const onClickWrap = (e) => {
            if (!pWrap.classList.contains(cfg.openClass)) return;
            if (pInner && pInner.contains(e.target)) return;
            closeAll();
          };
          pWrap.addEventListener('click', onClickWrap);
        });

        const onDocClick = (e) => {
          if (!cfg.closeOnOutside) return;
          const inside = pairs.some(({ t, pInner }) => t.contains(e.target) || (pInner && pInner.contains(e.target)));
          if (!inside) closeAll();
        };

        const onKey = (e) => {
          if (!cfg.closeOnEsc) return;
          if (e.key === 'Escape') closeAll();
        };

        document.addEventListener('click', onDocClick);
        document.addEventListener('keydown', onKey);

        submenuMap.set(root, { ok: true });
      });
    }
  };

  // ===== widgetMove =====
  const widgetMove = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({ items: [], mode: 'append', observe: true }, p);

      const apply = () => {
        (cfg.items || []).forEach(item => {
          const fromSel = item.from, toSel = item.to;
          const mode = item.mode || cfg.mode;
          if (!fromSel || !toSel) return;

          Core.whenBothExist(fromSel, toSel, (fromEl, toEl) => {
            if (toEl.contains(fromEl)) return;
            if (mode === 'replace') { toEl.innerHTML = ''; toEl.appendChild(fromEl); }
            else if (mode === 'prepend') { toEl.insertBefore(fromEl, toEl.firstChild); }
            else { toEl.appendChild(fromEl); }
          });
        });
      };

      apply();
      if (cfg.observe) Core.observe(apply);
    }
  };

  // ===== activePage =====
  const activePage = {
    init(rootSel, p = {}) {
      const cfg = Object.assign({
        containers: ['.uc-header', '.uc-menu'],
        pageSel: '.page',
        pageElemSel: '.page-elem',
        activeClass: 'is-active',
        linkActiveClass: 'is-active'
      }, p);

      const run = () => {
        const cur = (location.pathname || '/').replace(/\/$/, '') || '/';

        cfg.containers.forEach(sel => {
          const box = Core.qs(sel);
          if (!box) return;

          const pages = Core.qsa(cfg.pageSel, box);
          if (pages.length) {
            pages.forEach(page => {
              const link = page.matches('a[href]') ? page : Core.qs('a[href]', page);
              const href = link ? link.getAttribute('href') : null;
              const norm = href ? Core.normPath(href) : null;
              const isActive = norm && norm === cur;

              page.classList.toggle(cfg.activeClass, !!isActive);
              if (link) link.classList.toggle(cfg.linkActiveClass, !!isActive);

              const deco = Core.qs(cfg.pageElemSel, page);
              if (deco) deco.classList.toggle(cfg.activeClass, !!isActive);
            });
            return;
          }

          Core.qsa('a[href]', box).forEach(a => {
            const href = a.getAttribute('href');
            const norm = href ? Core.normPath(href) : null;
            a.classList.toggle(cfg.linkActiveClass, !!(norm && norm === cur));
          });
        });
      };

      run();
      w.addEventListener('popstate', run);
    }
  };

  const MyMods = w.MyMods || {};
  MyMods.version = '0.4.0';

  MyMods.Core = Core;
  MyMods.Tilda = Tilda;

  MyMods.stickyHeader = stickyHeader;
  MyMods.burgerMenu = burgerMenu;
  MyMods.submenu = submenu;
  MyMods.widgetMove = widgetMove;
  MyMods.activePage = activePage;

  MyMods.init = (rootSel, config = {}) => {
    if (config.stickyHeader) MyMods.stickyHeader.init(rootSel, config.stickyHeader);
    if (config.burgerMenu)   MyMods.burgerMenu.init(rootSel, config.burgerMenu);
    if (config.submenu)      MyMods.submenu.init(rootSel, config.submenu);
    if (config.widgetMove)   MyMods.widgetMove.init(rootSel, config.widgetMove);
    if (config.activePage)   MyMods.activePage.init(rootSel, config.activePage);
    console.log('[MyMods] init ok, version', MyMods.version);
  };

  w.MyMods = MyMods;
  console.log('[MyMods] library loaded, version', MyMods.version);

})(window);
